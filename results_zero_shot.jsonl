{"function_name": "InteractWithCharacter", "code": "\tpublic void InteractWithCharacter()\n\t{\n\t\tif (_gameStateManager.CurrentGameState == GameState.Gameplay)\n\t\t{\n\t\t\tDialogueDataSO displayDialogue = _questData.InteractWithCharacter(_actor, false, false);\n\t\t\t//Debug.Log(\"dialogue \" + displayDialogue + \"actor\" + _actor);\n\t\t\tif (displayDialogue != null)\n\t\t\t{\n\t\t\t\t_currentDialogue = displayDialogue;\n\t\t\t\tStartDialogue();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPlayDefaultDialogue();\n\t\t\t}\n\t\t}\n\n\t}\n", "ground_truth": "start a dialogue when interaction\n\nsome Steps need to be instantanious. And do not need the interact button.\n\nwhen interaction again, restart same dialogue.\n", "prediction": "// This function handles interaction with a character during gameplay, retrieving and displaying dialogue based on the current game state and quest data. If no dialogue is available, it plays a default response.", "mode": "zero-shot"}
{"function_name": "MenuItem", "code": "\t//[MenuItem(\"ChopChop/Quest Editor\")]\n\tpublic static void ShowWindow()\n\t{\n\t\tQuestEditorWindow wnd = GetWindow<QuestEditorWindow>();\n\t\twnd.titleContent = new GUIContent(\"Quest Editor\");\n\n\t\t// Sets a minimum size to the window.\n\t\twnd.minSize = new Vector2(250, 250);\n\t}\n", "ground_truth": "Note: Hidden from the tools because it's not fully functional at the moment\n", "prediction": "// This function opens the Quest Editor window in Unity, setting its title to \"Quest Editor\" and establishing a minimum size of 250x250 pixels.", "mode": "zero-shot"}
{"function_name": "func_at_line_15", "code": "\t/// (Editor only)\n\t/// Gets a locale to use in edit mode in the editor.\n\t/// </summary>\n\t/// <param name=\"tableCollection\">Optional table collection with which to filter the available locales.</param>\n\t/// <returns>The locale, null if none usable found.</returns>\n\n\tstatic Locale Editor_GetValidLocaleInEditMode(LocalizationTableCollection tableCollection)\n\t{\n\t\tforeach (var locale in LocalizationEditorSettings.GetLocales())\n\t\t{\n\t\t\tif (locale != null && (tableCollection == null || tableCollection.GetTable(locale.Identifier) != null))\n\t\t\t\treturn locale;\n\t\t}\n\n\t\treturn null;\n\t}\n", "ground_truth": "<summary>\n", "prediction": "/// Retrieves a valid locale for edit mode from the available locales, filtering by an optional table collection. Returns the first usable locale or null if none is found.", "mode": "zero-shot"}
{"function_name": "GetLocalizedStringImmediateSafe", "code": "\tpublic static string GetLocalizedStringImmediateSafe(this LocalizedString localizedStringReference)\n\t{\n\t\t// If we are in the editor in edit mode, we need to find a valid locale and get the localized string from it:\n#if UNITY_EDITOR\n\t\tif (EditorApplication.isPlaying)\n\t\t\treturn string.Empty;\n\n\t\tstring text = null;\n\t\tif (!localizedStringReference.IsEmpty)\n\t\t{\n\t\t\tvar tableCollection = LocalizationEditorSettings.GetStringTableCollection(localizedStringReference.TableReference);\n\t\t\tLocale locale = Editor_GetValidLocaleInEditMode(tableCollection);\n\t\t\tif (locale != null)\n\t\t\t{\n\t\t\t\tStringTable table = (StringTable)tableCollection.GetTable(locale.Identifier);\n\t\t\t\tif (table != null)\n\t\t\t\t\tif (table.GetEntryFromReference(localizedStringReference.TableEntryReference)!=null)\n\t\t\t\t\ttext = table.GetEntryFromReference(localizedStringReference.TableEntryReference).LocalizedValue;\n\t\t\t}\n\t\t}\n\t\treturn text;\n#else\n\t\t// At runtime (build or editor in play mode), we just get the localized string normally:\n\t\treturn localizedStringReference.GetLocalizedString();\n#endif\n\t}\n", "ground_truth": "<summary>\n\nGets the localized string from an already loaded table, taking into account whether we are in edit mode, play mode, or a build.\n\n</summary>\n\n<param name=\"localizedStringReference\">The <see cref=\"LocalizedString\"/>.</param>\n\n<returns>The localized string.</returns>\n", "prediction": "This function retrieves a localized string based on a `LocalizedString` reference. In the Unity editor's edit mode, it finds a valid locale and fetches the string from the appropriate string table; otherwise, it returns the localized string directly during runtime or play mode.", "mode": "zero-shot"}
{"function_name": "OnAdvance", "code": "\tprivate void OnAdvance()\n\t{\n\t\tif (_isPaused)\n\t\t{\n\t\t\tResumeTimeline();\n\t\t\tLineEnded();\n\t\t}\n\t}\n", "ground_truth": "<summary>\n\nThis callback is executed when the player presses the button to advance dialogues. If the Timeline is currently paused due to a <c>DialogueControlClip</c>, it will resume its playback.\n\n</summary>\n", "prediction": "// This function resumes the timeline and marks the line as ended if the game is currently paused.", "mode": "zero-shot"}
{"function_name": "PauseTimeline", "code": "\tvoid PauseTimeline()\n\t{\n\t\t_isPaused = true;\n\t\t_activePlayableDirector.playableGraph.GetRootPlayable(0).SetSpeed(0);\n\t}\n", "ground_truth": "<summary>\n\nCalled by <c>DialogueControlClip</c> on the Timeline.\n\n</summary>\n", "prediction": "// Pauses the timeline playback by setting the speed of the root playable to zero and marking the timeline as paused.", "mode": "zero-shot"}
{"function_name": "OnTriggerEnter", "code": "\tprivate void OnTriggerEnter(Collider other)\n\t{\n\t\t//Fake event raise to test quicker\n\t\t_playSpeceficCutscene.RaiseEvent();\n\t}\n", "ground_truth": "THIS WILL BE REMOVED LATER WHEN WE HAVE ALL EVENTS SET UP, NOW WE ONLY NEED IT TO TEST CUTSCENE WITH TRIGGER\n\nRemember to remove collider componenet when we remove this\n", "prediction": "// This Unity function triggers a specific cutscene event when another collider enters the trigger zone.", "mode": "zero-shot"}
{"function_name": "ProcessFrame", "code": "\tpublic override void ProcessFrame(Playable playable, FrameData info, object playerData)\n\t{\n\t\tif (_dialoguePlayed)\n\t\t\treturn;\n\n\t\tif (Application.isPlaying)  //TODO: Find a way to \"play\" dialogue lines even when scrubbing the Timeline not in Play Mode\n\t\t{\n\t\t\t// Need to ask the CutsceneManager if the cutscene is playing, since the graph is not actually stopped/paused: it's just going at speed 0.\n\t\t\tif (playable.GetGraph().IsPlaying())\n\t\t\t//&& cutsceneManager.IsCutscenePlaying) Need to find an alternative to this \n\t\t\t{\n\t\t\t\tif (_dialogueLine != null && _actor != null)\n\t\t\t\t{\n\t\t\t\t\tif (PlayDialogueEvent != null)\n\t\t\t\t\t\tPlayDialogueEvent.RaiseEvent(_dialogueLine, _actor);\n\t\t\t\t\t_dialoguePlayed = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning(\"This clip contains no DialogueLine\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n", "ground_truth": "<summary>\n\nDisplays a line of dialogue on screen by interfacing with the <c>CutsceneManager</c>. \n\n</summary>\n", "prediction": "This function processes a frame in a playable timeline, triggering a dialogue event if it hasn't been played yet and the timeline is actively playing, while also checking for the presence of a dialogue line and actor.", "mode": "zero-shot"}
{"function_name": "InitiateFade", "code": "\tprivate void InitiateFade(bool fadeIn, float duration, Color desiredColor)\n\t{\n\t\t_imageComponent.DOBlendableColor(desiredColor, duration);\n\t}\n", "ground_truth": "<summary>\n\nControls the fade-in and fade-out.\n\n</summary>\n\n<param name=\"fadeIn\">If false, the screen becomes black. If true, rectangle fades out and gameplay is visible.</param>\n\n<param name=\"duration\">How long it takes to the image to fade in/out.</param>\n\n<param name=\"color\">Target color for the image to reach. Disregarded when fading out.</param>\n", "prediction": "// Initiates a color fade effect on the image component, transitioning to the specified desired color over the given duration.", "mode": "zero-shot"}
{"function_name": "dialogue", "code": "/// Keeps track of choices in the dialogue (if any) and then gives back control to gameplay when appropriate.\n/// </summary>\npublic class DialogueManager : MonoBehaviour\n{\n\t[SerializeField] private List<ActorSO> _actorsList = default;\n\t[SerializeField] private InputReader _inputReader = default;\n\t[SerializeField] private GameStateSO _gameState = default;\n\n\t[Header(\"Listening on\")]\n\t[SerializeField] private DialogueDataChannelSO _startDialogue = default;\n\t[SerializeField] private DialogueChoiceChannelSO _makeDialogueChoiceEvent = default;\n\n\t[Header(\"Broadcasting on\")]\n\t[SerializeField] private DialogueLineChannelSO _openUIDialogueEvent = default;\n\t[SerializeField] private DialogueChoicesChannelSO _showChoicesUIEvent = default;\n\t[SerializeField] private IntEventChannelSO _endDialogueWithTypeEvent = default;\n\t[SerializeField] private VoidEventChannelSO _continueWithStep = default;\n\t[SerializeField] private VoidEventChannelSO _playIncompleteDialogue = default;\n\t[SerializeField] private VoidEventChannelSO _makeWinningChoice = default;\n\t[SerializeField] private VoidEventChannelSO _makeLosingChoice = default;\n\n\tprivate int _counterDialogue;\n\tprivate int _counterLine;\n\tprivate bool _reachedEndOfDialogue { get => _counterDialogue >= _currentDialogue.Lines.Count; }\n\tprivate bool _reachedEndOfLine { get => _counterLine >= _currentDialogue.Lines[_counterDialogue].TextList.Count; }\n\tprivate DialogueDataSO _currentDialogue = default;\n\n\tprivate void Start()\n\t{\n\t\t_startDialogue.OnEventRaised += DisplayDialogueData;\n\t}\n\n\t/// <summary>\n\t/// Displays DialogueData in the UI, one by one.\n\t/// </summary>\n\tpublic void DisplayDialogueData(DialogueDataSO dialogueDataSO)\n\t{\n\t\tif (_gameState.CurrentGameState != GameState.Cutscene) // the dialogue state is implied in the cutscene state\n\t\t\t_gameState.UpdateGameState(GameState.Dialogue);\n\n\t\t_counterDialogue = 0;\n\t\t_counterLine = 0;\n\t\t_inputReader.EnableDialogueInput();\n\t\t_inputReader.AdvanceDialogueEvent += OnAdvance;\n\t\t_currentDialogue = dialogueDataSO;\n\n\t\tif (_currentDialogue.Lines != null)\n\t\t{\n\t\t\tActorSO currentActor = _actorsList.Find(o => o.ActorId == _currentDialogue.Lines[_counterDialogue].Actor); // we don't add a controle, because we need a null reference exeption if the actor is not in the list\n\t\t\tDisplayDialogueLine(_currentDialogue.Lines[_counterDialogue].TextList[_counterLine], currentActor);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.LogError(\"Check Dialogue\");\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Displays a line of dialogue in the UI, by requesting it to the <c>DialogueManager</c>.\n\t/// This function is also called by <c>DialogueBehaviour</c> from clips on Timeline during cutscenes.\n\t/// </summary>\n\t/// <param name=\"dialogueLine\"></param>\n\tpublic void DisplayDialogueLine(LocalizedString dialogueLine, ActorSO actor)\n\t{\n\t\t_openUIDialogueEvent.RaiseEvent(dialogueLine, actor);\n\t}\n\n\tprivate void OnAdvance()\n\t{\n\t\t_counterLine++;\n\t\tif (!_reachedEndOfLine)\n\t\t{\n\t\t\tActorSO currentActor = _actorsList.Find(o => o.ActorId == _currentDialogue.Lines[_counterDialogue].Actor); // we don't add a controle, because we need a null reference exeption if the actor is not in the list\n\t\t\tDisplayDialogueLine(_currentDialogue.Lines[_counterDialogue].TextList[_counterLine], currentActor);\n\t\t}\n\t\telse if (_currentDialogue.Lines[_counterDialogue].Choices != null\n\t\t\t\t&& _currentDialogue.Lines[_counterDialogue].Choices.Count > 0)\n\t\t{\n\t\t\tif (_currentDialogue.Lines[_counterDialogue].Choices.Count > 0)\n\t\t\t{\n\t\t\t\tDisplayChoices(_currentDialogue.Lines[_counterDialogue].Choices);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_counterDialogue++;\n\t\t\tif (!_reachedEndOfDialogue)\n\t\t\t{\n\t\t\t\t_counterLine = 0;\n\n\t\t\t\tActorSO currentActor = _actorsList.Find(o => o.ActorId == _currentDialogue.Lines[_counterDialogue].Actor); // we don't add a controle, because we need a null reference exeption if the actor is not in the list\n\t\t\t\tDisplayDialogueLine(_currentDialogue.Lines[_counterDialogue].TextList[_counterLine], currentActor);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDialogueEndedAndCloseDialogueUI();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void DisplayChoices(List<Choice> choices)\n\t{\n\t\t_inputReader.AdvanceDialogueEvent -= OnAdvance;\n\n\t\t_makeDialogueChoiceEvent.OnEventRaised += MakeDialogueChoice;\n\t\t_showChoicesUIEvent.RaiseEvent(choices);\n\t}\n\n\tprivate void MakeDialogueChoice(Choice choice)\n\t{\n\t\t_makeDialogueChoiceEvent.OnEventRaised -= MakeDialogueChoice;\n\n\t\tswitch (choice.ActionType)\n\t\t{\n\t\t\tcase ChoiceActionType.ContinueWithStep:\n\t\t\t\tif (_continueWithStep != null)\n\t\t\t\t\t_continueWithStep.RaiseEvent();\n\t\t\t\tif (choice.NextDialogue != null)\n\t\t\t\t\tDisplayDialogueData(choice.NextDialogue);\n\t\t\t\tbreak;\n\n\t\t\tcase ChoiceActionType.WinningChoice:\n\t\t\t\tif (_makeWinningChoice != null)\n\t\t\t\t\t_makeWinningChoice.RaiseEvent();\n\t\t\t\tbreak;\n\n\t\t\tcase ChoiceActionType.LosingChoice:\n\t\t\t\tif (_makeLosingChoice != null)\n\t\t\t\t\t_makeLosingChoice.RaiseEvent();\n\t\t\t\tbreak;\n\n\t\t\tcase ChoiceActionType.DoNothing:\n\t\t\t\tif (choice.NextDialogue != null)\n\t\t\t\t\tDisplayDialogueData(choice.NextDialogue);\n\t\t\t\telse\n\t\t\t\t\tDialogueEndedAndCloseDialogueUI();\n\t\t\t\tbreak;\n\n\t\t\tcase ChoiceActionType.IncompleteStep:\n\t\t\t\tif (_playIncompleteDialogue != null)\n\t\t\t\t\t_playIncompleteDialogue.RaiseEvent();\n\t\t\t\tif (choice.NextDialogue != null)\n\t\t\t\t\tDisplayDialogueData(choice.NextDialogue);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic void CutsceneDialogueEnded()\n\t{\n\t\tif (_endDialogueWithTypeEvent != null)\n\t\t\t_endDialogueWithTypeEvent.RaiseEvent((int)DialogueType.DefaultDialogue);\n\t}\n\n\tprivate void DialogueEndedAndCloseDialogueUI()\n\t{\n\t\t//raise the special event for end of dialogue if any \n\t\t_currentDialogue.FinishDialogue();\n\n\t\t//raise end dialogue event \n\t\tif (_endDialogueWithTypeEvent != null)\n\t\t\t_endDialogueWithTypeEvent.RaiseEvent((int)_currentDialogue.DialogueType);\n\n\t\t_inputReader.AdvanceDialogueEvent -= OnAdvance;\n\t\t_gameState.ResetToPreviousGameState();\n\t\t\n\t\tif (_gameState.CurrentGameState == GameState.Gameplay\n\t\t\t|| _gameState.CurrentGameState == GameState.Combat)\n\t\t\t_inputReader.EnableGameplayInput();\n\t}\n}\n", "ground_truth": "<summary>\n\nTakes care of all things dialogue, whether they are coming from within a Timeline or just from the interaction with a character, or by any other mean.\n", "prediction": "The `DialogueManager` class manages the flow of dialogue in a game, handling the display of dialogue lines and choices, transitioning between dialogue states, and updating the game state accordingly. It also listens for player input to advance dialogue or make choices.", "mode": "zero-shot"}
{"function_name": "CreateAssetMenu", "code": "[CreateAssetMenu(fileName = \"new Dialogue\", menuName = \"Dialogues/Dialogue Data\")]\npublic class DialogueDataSO : ScriptableObject\n{\n\t[SerializeField] private List<Line> _lines = default;\n\t[SerializeField] private DialogueType _dialogueType = default;\n\t[SerializeField] private VoidEventChannelSO _endOfDialogueEvent = default;\n\t\n\tpublic VoidEventChannelSO EndOfDialogueEvent => _endOfDialogueEvent;\n\tpublic List<Line> Lines => _lines;\n\n\tpublic DialogueType DialogueType\n\t{\n\t\tget { return _dialogueType; }\n\t\tset { _dialogueType = value; }\n\t}\n\n\tpublic void FinishDialogue()\n\t{\n\t\tif (EndOfDialogueEvent != null)\n\t\t\tEndOfDialogueEvent.RaiseEvent();\n\t}\n\n#if UNITY_EDITOR\n\tprivate void OnEnable()\n\t{\n\t\tSetDialogueLines(this.name);\n\t}\n\tpublic DialogueDataSO(string dialogueName)\n\t{\n\t\tSetDialogueLines(dialogueName);\n\t}\n\tvoid SetDialogueLines(string dialogueName)\n\t{\n\t\tif (_lines == null)\n\t\t\t_lines = new List<Line>();\n\n\t\t_lines.Clear();\n\t\tint dialogueIndex = 0;\n\t\tLine _dialogueLine = new Line();\n\n\t\tdo\n\t\t{\n\t\t\tdialogueIndex++;\n\t\t\t_dialogueLine = new Line(\"D\" + dialogueIndex + \"-\" + dialogueName);\n\t\t\tif (_dialogueLine.TextList != null)\n\t\t\t\t_lines.Add(_dialogueLine);\n\n\t\t} while (_dialogueLine.TextList != null);\n\t}\n\n\t/// <summary>\n\t/// This function is only useful for the Questline Tool in Editor to remove a Questline\n\t/// </summary>\n\t/// <returns>The local path</returns>\n\tpublic string GetPath()\n\t{\n\t\treturn AssetDatabase.GetAssetPath(this);\n\t}\n#endif\n}\n", "ground_truth": "<summary>\n\nA Dialogue is a list of consecutive DialogueLines. They play in sequence using the input of the player to skip forward.\n\nIn future versions it might contain support for branching conversations.\n\n</summary>\n", "prediction": "The `FinishDialogue` method triggers the `EndOfDialogueEvent` if it is not null, signaling that the dialogue has concluded.", "mode": "zero-shot"}
{"function_name": "CreateAssetMenu", "code": "[CreateAssetMenu(fileName = \"newActor\", menuName = \"Dialogues/Actor\")]\npublic class ActorSO : ScriptableObject\n{\n\t[SerializeField] private ActorID _actorId = default;\n\t[SerializeField] private LocalizedString _actorName = default;\n\n\tpublic ActorID ActorId { get => _actorId; }\n\tpublic LocalizedString ActorName { get => _actorName; }\n}\n", "ground_truth": "<summary>\n\nScriptable Object that represents an \"Actor\", that is the protagonist of a Dialogue\n\n</summary>\n", "prediction": "This Unity ScriptableObject class defines an actor with an associated ID and localized name, allowing for easy creation and management of dialogue actors in the game.", "mode": "zero-shot"}
{"function_name": "SetupProtagonistVirtualCamera", "code": "\tpublic void SetupProtagonistVirtualCamera()\n\t{\n\t\tTransform target = _protagonistTransformAnchor.Value;\n\n\t\tfreeLookVCam.Follow = target;\n\t\tfreeLookVCam.LookAt = target;\n\t\tfreeLookVCam.OnTargetObjectWarped(target, target.position - freeLookVCam.transform.position - Vector3.forward);\n\t}\n", "ground_truth": "<summary>\n\nProvides Cinemachine with its target, taken from the TransformAnchor SO containing a reference to the player's Transform component.\n\nThis method is called every time the player is reinstantiated.\n\n</summary>\n", "prediction": "// This function configures a virtual camera to follow and look at the protagonist's transform, adjusting its position to account for any warping.", "mode": "zero-shot"}
{"function_name": "TryGetTransiton", "code": "\t\tpublic bool TryGetTransiton(out State state)\n\t\t{\n\t\t\tstate = ShouldTransition() ? _targetState : null;\n\t\t\treturn state != null;\n\t\t}\n", "ground_truth": "<summary>\n\nChecks wether the conditions to transition to the target state are met.\n\n</summary>\n\n<param name=\"state\">Returns the state to transition to. Null if the conditions aren't met.</param>\n\n<returns>True if the conditions are met.</returns>\n", "prediction": "// Attempts to retrieve the target state for a transition if the condition is met; returns true if successful, false otherwise.", "mode": "zero-shot"}
{"function_name": "Awake", "code": "\t\tpublic virtual void Awake(StateMachine stateMachine) { }\n", "ground_truth": "<summary>\n\nAwake is called when creating a new instance. Use this method to cache the components needed for the action.\n\n</summary>\n\n<param name=\"stateMachine\">The <see cref=\"StateMachine\"/> this instance belongs to.</param>\n", "prediction": "// This method is called when the script instance is being loaded, allowing for initialization of the StateMachine.", "mode": "zero-shot"}
{"function_name": "GetStatement", "code": "\t\tinternal bool GetStatement()\n\t\t{\n\t\t\tif (!_isCached)\n\t\t\t{\n\t\t\t\t_isCached = true;\n\t\t\t\t_cachedStatement = Statement();\n\t\t\t}\n\n\t\t\treturn _cachedStatement;\n\t\t}\n", "ground_truth": "<summary>\n\nWrap the <see cref=\"Statement\"/> so it can be cached.\n\n</summary>\n", "prediction": "// This function retrieves a cached statement, generating it only once if it hasn't been cached yet.", "mode": "zero-shot"}
{"function_name": "Awake", "code": "\t\tpublic virtual void Awake(StateMachine stateMachine) { }\n", "ground_truth": "<summary>\n\nAwake is called when creating a new instance. Use this method to cache the components needed for the condition.\n\n</summary>\n\n<param name=\"stateMachine\">The <see cref=\"StateMachine\"/> this instance belongs to.</param>\n", "prediction": "// This method is called when the script instance is being loaded, allowing for initialization of the StateMachine.", "mode": "zero-shot"}
{"function_name": "GetCondition", "code": "\t\tinternal StateCondition GetCondition(StateMachine stateMachine, bool expectedResult, Dictionary<ScriptableObject, object> createdInstances)\n\t\t{\n\t\t\tif (!createdInstances.TryGetValue(this, out var obj))\n\t\t\t{\n\t\t\t\tvar condition = CreateCondition();\n\t\t\t\tcondition._originSO = this;\n\t\t\t\tcreatedInstances.Add(this, condition);\n\t\t\t\tcondition.Awake(stateMachine);\n\n\t\t\t\tobj = condition;\n\t\t\t}\n\n\t\t\treturn new StateCondition(stateMachine, (Condition)obj, expectedResult);\n\t\t}\n", "ground_truth": "<summary>\n\nWill create a new custom <see cref=\"Condition\"/> or use an existing one inside <paramref name=\"createdInstances\"/>.\n\n</summary>\n", "prediction": "// This function retrieves or creates a StateCondition based on the current ScriptableObject, initializing it if it doesn't already exist in the provided dictionary of created instances.", "mode": "zero-shot"}
{"function_name": "GetAction", "code": "\t\tinternal StateAction GetAction(StateMachine stateMachine, Dictionary<ScriptableObject, object> createdInstances)\n\t\t{\n\t\t\tif (createdInstances.TryGetValue(this, out var obj))\n\t\t\t\treturn (StateAction)obj;\n\n\t\t\tvar action = CreateAction();\n\t\t\tcreatedInstances.Add(this, action);\n\t\t\taction._originSO = this;\n\t\t\taction.Awake(stateMachine);\n\t\t\treturn action;\n\t\t}\n", "ground_truth": "<summary>\n\nWill create a new custom <see cref=\"StateAction\"/> or return an existing one inside <paramref name=\"createdInstances\"/>\n\n</summary>\n", "prediction": "// Retrieves or creates a StateAction instance associated with the current ScriptableObject, storing it in the provided dictionary for reuse. If the instance already exists, it returns the existing one; otherwise, it creates a new action, initializes it, and adds it to the dictionary.", "mode": "zero-shot"}
{"function_name": "OnFocus", "code": "\t\tprivate void OnFocus()\n\t\t{\n\t\t\t// Calling CreateListView() from here when the window is docked\n\t\t\t// throws a NullReferenceException in UnityEditor.DockArea:OnEnable().\n\t\t\tif (_doRefresh == false)\n\t\t\t\t_doRefresh = true;\n\t\t}\n", "ground_truth": "<summary>\n\nUpdate list every time we gain focus\n\n</summary>\n", "prediction": "// This function sets a flag to refresh the view when the window gains focus, avoiding a NullReferenceException during initialization in a docked state.", "mode": "zero-shot"}
{"function_name": "OnValidate", "code": "\tprivate void OnValidate()\n    {\n        // Clamp the lightmap scale to the range [0,1]\n        if (_lightmapScale < 0f)\n        {\n            _lightmapScale = 0f;\n        }\n\n        // Update lightmap scale for MeshRenderers within component and all descendants\n        MeshRenderer[] meshRenderers = GetComponentsInChildren<MeshRenderer>();\n        foreach (MeshRenderer meshRenderer in meshRenderers)\n        {\n            meshRenderer.scaleInLightmap = _lightmapScale;\n        }\n    }\n", "ground_truth": "Called when the Lightmap Scale field is changed in the component editor\n", "prediction": "// This Unity function clamps the `_lightmapScale` value to a minimum of 0 and updates the `scaleInLightmap` property for all `MeshRenderer` components in the object and its children.", "mode": "zero-shot"}
{"function_name": "IssueTeleport", "code": "\tpublic void IssueTeleport()\n\t{\n\t\t_teleporter.Teleport(_location, _path);\n\t}\n", "ground_truth": "Called by the UI button's UnityEvent\n", "prediction": "// Initiates a teleportation process by calling the Teleport method on the _teleporter object, using the specified _location and _path.", "mode": "zero-shot"}
{"function_name": "CustomPropertyDrawer", "code": "[CustomPropertyDrawer(typeof(ReadOnlyAttribute))]\npublic class ReadOnlyDrawer : PropertyDrawer\n{\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n    {\n        bool previousGUIState = GUI.enabled;\n\n        GUI.enabled = false;\n        EditorGUI.PropertyField(position, property, label);\n        GUI.enabled = previousGUIState;\n    }\n}", "ground_truth": "<summary>\n\nCustom drawer for the ReadOnly attribute\n\n</summary>\n", "prediction": "This `ReadOnlyDrawer` class creates a custom property drawer for fields marked with the `ReadOnlyAttribute`, rendering them in the Inspector as disabled, preventing any edits while still displaying their values.", "mode": "zero-shot"}
{"function_name": "DrawNonEditableScriptReference", "code": "\tpublic void DrawNonEditableScriptReference<T>() where T : Object\n\t{\n\t\tGUI.enabled = false;\n\n\t\tif (typeof(ScriptableObject).IsAssignableFrom(typeof(T)))\n\t\t\tEditorGUILayout.ObjectField(\"Script\", MonoScript.FromScriptableObject((ScriptableObject)target), typeof(T), false);\n\t\telse if (typeof(MonoBehaviour).IsAssignableFrom(typeof(T)))\n\t\t\tEditorGUILayout.ObjectField(\"Script\", MonoScript.FromMonoBehaviour((MonoBehaviour)target), typeof(T), false);\n\n\t\tGUI.enabled = true;\n\t}\n", "ground_truth": "<summary>\n\nDraw the default, non-editable script field. Useful when creating a custom Inspector but we want it to look like a default one.\n\nPlus, it's handy to be able to click on the field to ping the Script in the Project window.\n\n</summary>\n\n<typeparam name=\"T\">Inspected type.</typeparam>\n", "prediction": "// This function displays a non-editable object field in the Unity Editor for a specified type T, which can be either a ScriptableObject or a MonoBehaviour, showing the associated script.", "mode": "zero-shot"}
{"function_name": "DrawTypeButtons", "code": "\tprivate void DrawTypeButtons()\n\t{\n\t\t_typeScrollViewPosition = GUILayout.BeginScrollView(_typeScrollViewPosition);\n\n\t\tfor (int i = 0; i < _types.Count; i++)\n\t\t{\n\t\t\tif (GUILayout.Button(GetNiceName(_types.ElementAt(i).Key), EditorStyles.foldout))\n\t\t\t{\n\t\t\t\t_typeIndex = i;\n\t\t\t\tGetAssets();\n\t\t\t\t_showingTypes = false;\n\t\t\t}\n\t\t}\n\n\t\tGUILayout.EndScrollView();\n\t}\n", "ground_truth": "<summary>\n\nDraws a scroll view list of Buttons for each ScriptableObject type.\n\n</summary>\n", "prediction": "// This function creates a scrollable list of buttons for each type in `_types`, allowing the user to select a type and retrieve its associated assets when a button is clicked.", "mode": "zero-shot"}
